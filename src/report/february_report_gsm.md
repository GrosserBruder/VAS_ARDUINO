<h1 align="center">ОТЧЁТ <br> о результатах работы за февраль 2021 года</h1>
 
#### За отчётный период было выполнено следующее:
#### 1. Совершенствование внешнего вида макета разрабатываемого программно-аппаратного комплекса.

Совершенствования внешнего вида макета, разрабатываемого ПАК включало в себя изготовку каркаса типовых военных зданий (стены, двери и крыша). В качестве материала использовалась ламинированная древесно-стружечная плита (ЛДСП). Так же были закуплены петельки и саморезы по дереву, для имитации открытия (закрытия) дверей (Рис. 1).
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/february/1_%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B8%D0%B9_%D0%B2%D0%B8%D0%B4_%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F_(%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%B8%D0%B5_%D0%B4%D0%B2%D0%B5%D1%80%D0%B8).png"/>
</p>
<p align="center">Рисунок 1 – Внешний вид здания (открытие двери)</p>

В качестве типовых зданий были выбраны (Рис. 2):
1.	Склад военно-технического имущества (ВТИ);
2.	Склад вооружения и военной техники (ВВТ).
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/february/2_%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B8%D0%B9_%D0%B2%D0%B8%D0%B4_%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B9_%D0%92%D0%A2%D0%98_%D0%B8_%D0%92%D0%92%D0%A2.png"/>
</p>
<p align="center">Рисунок 2 – Внешний вид зданий ВТИ и ВВТ</p>

Для срабатывания датчика с герконом (определяющий открытие двери) было подобрано идеальное расстояния срабатывания от самого геркона к монтированному на стену магниту. Расположение компонентов внутри удалённых объектов изображено на рисунке 3. 
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/february/3_%D1%80%D0%B0%D1%81%D0%BF%D0%BE%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2_%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B8_%D1%83%D0%B4%D0%B0%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D1%85_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2_(%D0%B2%D0%B8%D0%B4_%D1%81%D0%B2%D0%B5%D1%80%D1%85%D1%83).png/>
</p>
<p align="center">Рисунок 3 – Расположение компонентов внутри удалённых объектов (вид сверху)</p>

Разрабатываемый ПАК после совершенствования его внешнего вида выглядит следующий образом (Рис. 4).
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/february/4_%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B8%D0%B9_%D0%B2%D0%B8%D0%B4_%D0%9F%D0%90%D0%9A_%D0%BF%D0%BE%D1%81%D0%BB%D0%B5_%D1%81%D0%BE%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%B5%D0%B3%D0%BE_%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B5%D0%B3%D0%BE_%D0%B2%D0%B8%D0%B4%D0%B0.png"/>
</p>
<p align="center">Рисунок 4 – Внешний вид ПАК после совершенствования его внешнего вида</p>

#### 2. Пайка проводов на управляемых устройствах.

Разработанный ПАК подразумевает круглосуточную работу на установленных удалённых объектах. Для корректности считываемых данных со всех датчиков и сенсоров системы, а также бесперебойной передачи данных между устройствами необходимо повысить надёжность системы путём перехода от проводов типа «мама-мама», «папа-папа» и «мама-папа» к обычным медным проводам в оболочке, используемые в витой паре. Для соединения проводов между собой, соединения АКБ в качестве источника питания к плате Arduino, а также подключения датчиков системы необходимо прибегнуть к их аппаратной пайке. Для этого необходимо использовать (Рис. 5): 
1.	Паяльник или паяльная станция;
2.	Олово;
3.	Канифоль;
4.	Кусачки или зажигалка.
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/february/5_%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0_%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B5%D0%B3%D0%BE_%D0%BC%D0%B5%D1%81%D1%82%D0%B0_%D0%BF%D0%B5%D1%80%D0%B5%D0%B4_%D0%BF%D0%B0%D0%B9%D0%BA%D0%BE%D0%B9_%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%B4%D0%BE%D0%B2_%D0%BD%D0%B0_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D0%BC%D1%8B%D1%85_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D1%85.png"/>
</p>
<p align="center">Рисунок 5 – Подготовка рабочего места перед пайкой проводов на управляемых устройствах</p>

#### 3. Разработка, тестирование и отладка модуля оповещения по GSM каналу о несанкционированном доступе, задымлённости и низком уровне напряжения сети на удалённых объектах.

Для разработки модуля оповещения по GSM каналу о несанкционированном доступе, задымлённости и низком уровне напряжения сети на удалённых объектах необходимо доработать прошивку на главном управляющем устройстве. В зависимости от передаваемых с удалённых устройств значений с датчиков и модуля геркона будет выполняться специфичная бизнес логика для каждой отдельной ситуации, то есть формирование уникальных SMS сообщений для оправки по GSM каналу. Автоматизация процесса отправки сообщений осуществляется с помощью расширения программного кода уже интегрированного в ПАК GSM модуля и подключённой библиотеки iarduino_GSM. Данная библиотека может использовать как аппаратную, так и программную реализацию шины UART и позволяет устанавливать голосовые соединения и обмениваться SMS сообщениями (в том числе и на русском языке) используя несколько простых и понятных функций, представленных в таблице 1.
<p align="right">Таблица 1.</p>
<p align="center">Назначение функций библиотеки iarduino_GSM для работы с GSM/GPRS</p>

| Название функции | Назначение функции  |
| :----------------- | :-------------: |
| iarduino_GSM ОБЪЕКТ  | Создание объекта для работы с функциями и методами библиотеки iarduino_GSM  |
| begin( UART )  | Инициализация работы и указание объекта UART  |
| status()  | Получение состояния GSM  |
| pin( "PIN" )  | Ввод PIN-кода (CHV1)  |
| puk( "PUK", "PIN" )  | Ввод PUK-кода (PUK1) и нового PIN-кода (CHV1)  |
| pwr( ФЛАГ )  | Включение/выключение модуля  |
| reset()  | Перезагрузка модуля  |
| runAT( "КОМАНДА" [,ТАЙМАУТ [,ФЛАГ]] )  | Выполнение AT-команды  |
| runUSSD( "КОМАНДА" [,ТАЙМАУТ] )  | Выполнение USSD запроса  |
| signal()  | Получение уровня принимаемого сигнала  |
| SMSavailable()  | Получение количества принятых непрочитанных SMS сообщений  |
| SMSmax()  | Получение объема памяти SMS на SIM карте  |
| SMSread( ТЕКСТ [,АДРЕС [,ДАТА [,ID,КОЛИЧЕСТВО,НОМЕР]]] )  | Чтение SMS  |
| SMSsend( "ТЕКСТ" ,"АДРЕС" [,ID,КОЛИЧЕСТВО,НОМЕР] )  | Отправка SMS  |
| SMSsendClass( КЛАСС )  | Указание класса отправляемым SMS сообщениям  |
| TXTreadCoding( КОДИРОВКА )  | Указание кодировки для получаемого (выводимого) текста  |
| TXTsendCoding( КОДИРОВКА )  | Указание кодировки отправляемого (вводимого) текста  |
| TXTsendCodingDetect( 'п' )  | Автоопределение кодировки отправляемого текста  |
| CALLavailable( [ АДРЕС ] )  | Проверка наличия входящего (звонящего) голосового вызова  |
| CALLup()  | Ответ на входящий голосовой вызов (поднятие трубки)  |
| CALLend()  | Завершение голосовых вызовов (опускание трубки)  |
| CALLdial( "АДРЕС" )  | Инициализация исходящего голосового вызова (набор номера)  |
| CALLstatus()  | Получение состояния голосового вызова  |
| SOUNDdevice( [ УСТРОЙСТВО ] )  | Выбор устройства ввода/вывода звука  |
| SOUNDvolume( [ ГРОМКОСТЬ ] )  | Указание громкости звука  |
| SOUNDmute( [ ФЛАГ ] )  | Включение немого режима (режим без микрофона)  |

Первым делом необходимо проверить доступность GSM модуля с помощью функции status(). Вся обработка аварийных и нештатных ситуаций будет происходить внутри функции loop() внутри обработки принимаемых данных по RS485 протоколу:
```C++  
void loop() {
    if (ETrx.receiveData())
    {
 String convertIsOpenDoorValue; // String значение текущего положения двери
     char outstr[4];
     Serial.print("rxdata - ");
     Serial.println(rxdata.ID);
     switch (rxdata.ID)
     {
      case 1:
          turnOnOrOffLedGerkonPins(1);
          turnOnOrOffLedSmokePins(1);
          ……………………
	       …………………...
	   case 2:
          turnOnOrOffLedGerkonPins(2);
          turnOnOrOffLedSmokePins(2);
          ……………………
	       …………………...
  	   if(gsm.status()==GSM_OK){
           gsm.TXTsendCodingDetect("п"); 
           if(rxdata.isOpen == 1){
               Serial.println(F("Посылка SMS о несанкционированном доступе"));       
               gsm.SMSsend(F("На объекте 2 произошёл несанкционированный доступ!"), "79111587263"); 
           }
       if(rxdata.smoke > 2000){
           if(rxdata.temp > 35.0){
           Serial.println(F("Посылка SMS о задымление"));
           gsm.SMSsend(F("На объекте 2 произошло задымление!"), "79111587263");
           }else{
           Serial.println(F("Посылка SMS об утечки газа"));                                              
           gsm.SMSsend(F("На объекте 2 произошла утечка газа!"), "79111587263"); 
           }
           }
           if(rxdata.voltage != 0.0 && rxdata.voltage < 1.0){
            Serial.println(F("Посылка SMS о низком уровне напряжения сети"));                                              
            gsm.SMSsend(F("На объекте 2 необходимо заменить АКБ!"), "79111587263"); 
          }
       }

	   break;
	 }
	}
 }
```

Модуль успешно прошёл тестирование и была доказана работоспособность отправки SMS сообщений об аварийных и нештатных ситуаций с помощью GSM модуля.