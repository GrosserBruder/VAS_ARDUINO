<h1 align="center">ОТЧЁТ <br> о результатах работы за январь 2021 года</h1>
 
#### За отчётный период было выполнено следующее:
#### 1. Расширение элементной базы для совершенствования аппаратного модуля в части видеонаблюдения за объектами.

Для расширения элементной базы в части видеонаблюдения за объектами для аппаратной части был выбран и закуплен Arduino модуль камеры VGA OV7670. Он представляет собой плату с чипом CMOS OV7670 и небольшим количеством дополнительных деталей (Рис. 1). 
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/january/1_%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B8%D0%B9_%D0%B2%D0%B8%D0%B4_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F_VGA_%D0%BA%D0%B0%D0%BC%D0%B5%D1%80%D1%8B_OV7670.png"/>
</p>
<p align="center">Рисунок 1 – Внешний вид модуля VGA камеры OV7670</p>

Модуль видеокамеры предназначен для работы в составе электронного фотоаппарата, приборов видеотрансляции и видеозаписи. Информация на выходе модуля предоставляется в цифровом виде. VGA-модуль OV7670 совместим с различными микроконтроллерами. Высокая чувствительность позволяет работать в условиях низкой освещенности. По шине управления можно настроить качество изображения, формат данных и режим передачи. Особенности модуля позволяют автоматически поддерживать высокое качество изображения путем уменьшения или устранения зашумленности, выравнивания баланса цвета, повышения четкости изображения, установки оптимальной насыщенности, контрастности, гаммы и оттенка изображения. Эти особенности прибора позволяют применять его в системах видеонаблюдения, входящих в комплексы «умный дом», а также охранные системы и другие. Малый вес устройства позволяет устанавливать его на автоматические аэросистемы и различные подвижные платформы.

Данный модуль позволяет снимать изображения VGA формата (640х480), осуществлять их первичную обработку и по интерфейсу SCCB передавать их на управляющее устройство, например, модуль Arduino. 

Блок камеры позволяет формировать изображения в различных форматах: VGA (640x480), CIF (352x240) и прочих. Также возможна ручная настройка до 40х30. Скорость передачи изображения максимального разрешения (VGA) может достигать 30 кадров в секунду.

Камера также осуществляет предварительную обработку изображения, например, контроль экспозиции, усиления, баланс белого и прочее. Также поддерживаются различные варианты кодировки изображения (YUV, различные виды RGB). Передача данных осуществляется по протоколу SCCB. Основные характеристики данного модуля представлены в таблице 1.
<p align="right">Таблица 1.</p>
<p align="center">Характеристики модуля VGA камеры OV7670</p>

| Наименование | Значение  |
| :----------------- | :-------------: |
| Напряжение питания  | 3.3 В |
| Ток в активном режиме  | 20 мА |
| Ток в режиме сна  | <20 мА |
| Уровень напряжения на контактах сигналов  | 2.5 - 3 В |
| Интерфейсы  | SCCB (совместим с I2C) и параллельный 8 линий |
| Разрешающая способность матрицы  | 0,3 Мп: 1.  максимальная: 640 x 480 2.  минимальная 40 x 30 px |
| Форматы передачи цвета  | RGB565, RGB555, RGB444, YUV/YCbCr 4:2:2, GRB 4:2:2, Raw RGB Data |
| Количество кадров в секунду  | до 30 |
| Размер линзы  | 1/6’’ |
| Угол обзора  | 25° |
| Отношение сигнал/шум  | 46 дБ |
| Динамический диапазон  | 52 дБ |
| Методы автокоррекции  | AEC, AGC, AWB, ABF, ABLC |
| Температура окружающего воздуха во время работы  | 1. рекомендуемая: от 0 до 50 °С |
|                                                  | 2.  предельная: от –30 до 70 °C |
| Размер модуля  | 35 х 34 x 26 мм |
| Вес  | 12 г |

Для расширения элементной базы в рамках разрабатываемого программно-аппаратного комплекса был выбран именно модуль 
VGA камеры OV7670, так как он позволяет интегрировать данные на различные платы Arduino за счёт интерфейса I2C, а также имеет не высокую стоимость и способен записывать до 30 кадров в секунду. 

Данный модуль не поддерживает FIFO (w\o FIFO). FIFO – это память типа «первым вошёл-первым ушёл» (first input – first output). Модули с поддержкой FIFO имеют большее число ножек. Схема используемого модуля изображена на рисунке 2 (без поддержки FIFO).
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/january/2_%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D1%85%D0%B5%D0%BC%D0%B0_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F_VGA_%D0%BA%D0%B0%D0%BC%D0%B5%D1%80%D1%8B_OV7670.png"/>
</p>
<p align="center">Рисунок 2 – Принципиальная схема модуля VGA камеры OV7670</p>

Из приведенной схемы видно, что обвязка на ней минимальна и содержит только преобразователи напряжения. 

Назначение выводов и распиновка всех контактов на модуле VGA камеры OV7670 представлена на рисунке 3, а также в таблице 2
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/january/3_%D1%80%D0%B0%D1%81%D0%BF%D0%B8%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F_VGA_%D0%BA%D0%B0%D0%BC%D0%B5%D1%80%D1%8B_OV7670.png"/>
</p>
<p align="center">Рисунок 3 – Распиновка модуля VGA камеры OV7670 </p>
<p align="right">Таблица 2.</p>
<p align="center">Назначение выводов модуля VGA камеры OV7670</p>

| Название  | Тип  | Назначение  |
| :-----------------: | :-------------: | :-------------: | 
| 3V3  | Питание  | Вход питания. 3,3 В  |
| GND  | Общий провод  | Корпус  |
| SIO_C  | Вход  | Линия тактового сигнала интерфейса SCCB  |
| SIO_D  | Вход-выход  | Линия данных интерфейса SCCB управления  |
| VSYNC  | Выход  | Вертикальная синхронизация (для строк)  |
| HREF  | Выход  | Горизонтальная синхронизация (для колонок)  |
| PCLK  | Выход  | Пиксельная синхронизация (тактовый сигнал передачи байта из параллельного порта D0–D7)  |
| XCLK  | Вход  | Внешнее тактирование  |
| D7–D0  | Выходы  | Параллельный видеовыход  |
| RESET  | Вход  | Сброс (лог. 0)  |
| PWDN  | Вход  | Включение (лог. 0) и выключение (лог. 1)  |

Первым делом необходимо убедиться в работоспособности модуля. 
В спецификации указано, что для взаимодействия с камерой используется протокол SCCB, который совместим с I2C. Для этого в камере предусмотрены выводы SIO_C (system clock) и SIO_D (data transfer). Тут возникает первая проблема, так как рабочее напряжение Arduino UNO – 5 V, но камера требует 3.3 V. Для вывода SIO_C, который является входом, необходимо сделать простой делитель напряжения. А для вывода SIO_D такое решение не подойдёт, так как он является двунаправленным каналом. 
В документации к плате Arduino UNO сказано, что она имеет встроенную поддержку протокола I2C, с рабочим напряжением 3.5 V только на ножках 
A4 (SDA) и A5 (SCL). 

Подключение к I2C требует подтягивающих резисторов (pull-up resistors). Исходя из принципиальной схемы модуля, пины SIO_C и SIO_D просто выведены на внешние контакты и не содержат никаких подтягивающих резисторов. Резисторы нужно паять самостоятельно. 
В документации к камере описаны ошибочные номиналы резисторов, поэтому для корректного запуска камеры подтягивающие резисторы необходимо подбирать самостоятельно. Камера заработала только при сопротивлении резисторов на 3.3 K. Также подтягивающие резисторы нужно присоединять к напряжению 3.3 V, а не 5 V (Рис. 4).
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/january/4_%D0%BC%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE_%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D0%B0%D1%8F_%D1%81%D1%85%D0%B5%D0%BC%D0%B0_SCCB_(I2C)_%D0%BC%D0%B5%D0%B6%D0%B4%D1%83_%D0%BF%D0%BB%D0%B0%D1%82%D0%BE%D0%B9_Arduino_%D0%B8_OV7670.png"/>
</p>
<p align="center">Рисунок 4 – Минимально необходимая схема SCCB (I2C) между платой Arduino и OV7670</p>

Камера отвечает по протоколу I2C только если подана опорная частота на ножку XCLK (system clock). Этот входящий сигнал также нужно преобразовывать в 3.3 V. Для этого был использовал делитель напряжения на резисторах 4.7 K (Рис. 5). 
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/january/5_%D1%81%D1%85%D0%B5%D0%BC%D0%B0_%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F_VGA_%D0%BA%D0%B0%D0%BC%D0%B5%D1%80%D1%8B_OV670.png"/>
</p>
<p align="center">Рисунок 5 – Схема подключения модуля VGA камеры OV670</p>

С генерацией опорного сигнала также имеются некоторые несовместимости. Рекомендуемая рабочая частота модуля камеры OV7670 – 24 MHz. Однако Arduino Uno имеет рабочую частоту только лишь 16 MHz и не может выдавать 24 MHz. Но применив небольшое нестандартное решение, можно выдавать по ШИМ (PWM) частоту 8 MHz. Проверив корректную работоспособность камеры на этой частоте, и учитывая, что она имеет встроенный умножитель частоты (PLL) следует умножить частоту на 3 и получить желаемые 24 MHz. 

В спецификации сказано, что камера использует протокол SCCB. В ходе сравнения двух протоколов, не найдя отличий от I2C, в ходе разработки была использована стандартная библиотека для Arduino – Wire, которая без проблем работает с камерой.

В рамках разрабатываемого программно-аппаратного комплекса подключение логических контактов D0-D7 на модуле VGA камеры OV7670 осуществляется напрямую к плате Arduino к оставшимся незанятым аналоговым и цифровым сигналам (Рис. 6). 
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/january/6_%D1%81%D1%85%D0%B5%D0%BC%D0%B0_%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BA%D0%BE%D0%BD%D1%82%D0%B0%D0%BA%D1%82%D0%BE%D0%B2_D0-D7_%D1%81_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F_VGA_%D0%BA%D0%B0%D0%BC%D0%B5%D1%80%D1%8B_OV670.png"/>
</p>
<p align="center">Рисунок 6 – Схема подключения контактов D0-D7 с модуля VGA камеры OV670 к Arduino Uno</p>

Модуль камеры занимает все свободные контакты на плате Arduino Uno (кроме одного), поэтому появляется проблема подключения уже внедрённых в разрабатываемый программно-аппаратный комплекс различных датчиков. Одна новая функция видеонаблюдения не должна заменять четыре существующих функции системы. Поэтому для внедрения функции видеонаблюдения в систему, необходимо добавить на каждое удалённый объект дополнительную плату Arduino Uno и синхронизировать её с платой, на которой установлены датчики по RS485 протоколу. Следовательно, при добавлении функции видеонаблюдения на удалённых объектах увеличивается время отклика (задержка) и передачи данных на управляющее устройство.


#### 2. Разработка, тестирование и отладка программного обеспечения для разрабатываемого модуля.

Первым делом подключаем пин D3 к XCLK. Модуль камеры не работает от 5 V. Это единственное соединение, для которого необходим делитель напряжения на стороне камеры. Это единственный цифровой выходной сигнал от Arduino к модулю OV7670 (все остальные - входы для Arduino). XCLK – это входные часы, которые заставляют камеру работать. Максимальная частота, которую может выдавать Arduino, составляет 8 MHz. Для полной скорости модулю камеры требуется 30 MHz, но восьми достаточно для отображения изображения со скоростью десять кадров в секунду.

Следующим шагом необходимо выполнить соединение по I2C. Подключаем пин А5 к SIOC, а пин A4 на SIOD. Затем нужно добавить подтягивающие резисторы 4.7 кОм к обоим проводам (от А5 до 4.7 кОм до 3.3 V, а А4 от 4.7 кОм до 3.3 V). I2C необходим для отправки данных конфигурации на камеру, таких как разрешение, формат пикселей и другие вещи, необходимые для первоначальной настройке камеры.

Следующим шагом необходимо соединить пин D2 к VSYNC. Это сигнал 3.3 V от камеры к Arduino. Это подключение может быть выполнено напрямую без делителя напряжения. Вертикальную синхронизацию необходимо использовать при разработке, так как нужно знать, когда начинается новый кадр. В противном случае для Arduino он выглядит как постоянный поток пикселей без начала и конца.

Следующим шагом необходимо соединить пин D12 к PCLK. Это также сигнал 3.3 V от камеры к Arduino, подключаемый напрямую. Пиксельная синхронизация необходима для определения точного времени считывания данных пикселей.

Следующим шагом необходимо подключить питание к камере. От вывода Arduino 3.3 V к входу 3.3 V камеры и от вывода Arduino GND к GND камеры.

Следующим этапом необходимо подключить контакт RESET камеры к 3.3 V и PWDN к GND. Пин сброса (RESET) обычно используется для сброса модуля камеры и выключения питания, чтобы выключить его. Но поскольку из-за подключения камеры к плате Arduino Uno на ней не осталось свободных контактов, поэтому камера будет работать постоянно. 

Завершающим этапом необходимо подключить контакты камеры с D0 по D3 к контактам Arduino от A0 до A3. Это младшие четыре бита пикселя.  А контакты камеры от D4 до D7 к контактам Arduino с D4 по D7. Это старшие четыре бита пикселя. Один целиковый пиксель равен одному байту.

После подключения модуля VGA камеры OV7670 к Arduino остаётся реализовать программную часть для данного модуля и убедиться в её правильной работоспособности. После аппаратного подключения был сделан вывод, что каждый модуль с камерой подключается к отдельной плате Arduino Uno из-за нехватки свободных контактов на плате Arduino для подключения других модулей ПАК. Так как все управляемые устройства должны быть взаимозаменяемыми, необходимо разработать универсальную прошивку, работающую на всех устройствах одинаково.

Для разработки прошивки для работы с модулем VGA камеры OV7670 использовался чистый язык C++. Была разработана библиотека «LiveOV7670Library» (заголовочные файлы с расширением .h и файлы алгоритмов работы с расширением .cpp), в которой содержатся классы, необходимые для обмена данными между Arduino Uno и модулем камеры. Для использования этой библиотеке в главном файле прошивки, её следует добавить в корневые библиотеки для Arduino:
1.  В Windows – C: \ Users \ <имя пользователя> \ Documents \ Arduino \ библиотеки.
2.  На Mac – / Пользователи / <имя пользователя> / Документы / Arduino / библиотеки.

А также были использованы встроенные в ArduinoIDE библиотеки, такие как <util/twi.h>, для работы по интерфейсу I2C и работа с программными прерываниями и регистрами микроконтроллера.

Функция setup() включает в себя все начальные настройки, необходимые только для захвата изображения. Первая функция –   arduinoUnoInut(), которая используется для инициализации платы Arduino Uno. Первоначально он отключает все глобальные прерывания и устанавливает конфигурации интерфейса связи, такие как тактовая частота ШИМ, выбор контактов прерывания, выбор предварительного размыкателя, добавление битов четности и стоповых битов.

```C++  
        void setup() {
        arduinoUnoInut();
        camInit();
        setResolution();
        setColor();
        writeReg(0x11, 10); //Earlier it had the value:writeReg(0x11, 12);
    }

    void arduinoUnoInut(void) {
        cli(); //disable interrupts
        /* Setup the 8MHz PWM clock. This will be on pin 11*/
        DDRB |= (1 << 3); //pin 11
        ASSR &= ~(_BV(EXCLK) | _BV(AS2));
        TCCR2A = (1 << COM2A0) | (1 << WGM21) | (1 << WGM20);
        TCCR2B = (1 << WGM22) | (1 << CS20);
        OCR2A = 0; //(F_CPU)/(2*(X+1))
        DDRC &= ~15; //low d0-d3 camera
        DDRD &= ~252; //d7-d4 and interrupt pins
        _delay_ms(3000);
      
        //set up twi for 100khz
        TWSR &= ~3; //disable prescaler for TWI
        TWBR = 72; //set to 100khz
      
        //enable serial
        UBRR0H = 0;
        UBRR0L = 1; //0 = 2M baud rate. 1 = 1M baud. 3 = 0.5M. 
                              //7 = 250k 207 is 9600 baud rate.
        UCSR0A |= 2; //double speed aysnc
        UCSR0B = (1 << RXEN0) | (1 << TXEN0); //Enable receiver and transmitter
        UCSR0C = 6; //async 1 stop bit 8bit char no parity bits
    }
```
После настройки Arduino необходимо настроить камеру. Для инициализации камеры необходимо изменить значения регистров со значения по умолчанию на пользовательское. Также необходимо добавить необходимую задержку в зависимости от частоты микроконтроллера, который используется. Поскольку медленные микроконтроллеры имеют меньшее время обработки, необходимо добавлять больше задержки между захватом кадров.
```C++  
    void camInit(void){
        writeReg(0x12, 0x80);
        delay_ms(100);
        wrSensorRegs8_8(ov7670_default_regs);
        writeReg(REG_COM10, 32); //PCLK does not toggle on HBLANK.
    }

    void wrSensorRegs8_8(const struct regval_list reglist[]){
      uint8_t reg_addr, reg_val;
      const struct regval_list *next = reglist;
      while ((reg_addr != 0xff) | (reg_val != 0xff)){
          reg_addr = pgm_read_byte(&next->reg_num);
          reg_val = pgm_read_byte(&next->value);
          writeReg(reg_addr, reg_val);
          next++;
      }
    }

    void writeReg(uint8_t reg, uint8_t dat){
        //send start condition
        twiStart();
        twiAddr(camAddr_WR, TW_MT_SLA_ACK);
        twiWriteByte(reg, TW_MT_DATA_ACK);
        twiWriteByte(dat, TW_MT_DATA_ACK);
        TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO); //send stop
        _delay_ms(1);
    }
```
Камера настроена на получение изображения QVGA, поэтому необходимо выбрать разрешение. Функция настраивает регистр для получения изображения QVGA.
```C++
    void setResolution(void){
        writeReg(REG_COM3, 4);  // REG_COM3 enable scaling
        wrSensorRegs8_8(qvga_ov7670);
    }
```
Значение регистра установлено для вывода монохромного изображения. Функция устанавливает значения регистров из списка регистров, который предопределен в программе.
```C++
void setColor(void){
    wrSensorRegs8_8(yuv422_ov7670);
    // wrSensorRegs8_8(qvga_ov7670);
}

const struct regval_list yuv422_ov7670[] PROGMEM = {
    { REG_COM7, 0x0 },  /* Selects YUV mode */
    { REG_RGB444, 0 },  /* No RGB444 please */
    { REG_COM1, 0 },
    { REG_COM15, COM15_R00FF },
    { REG_COM9, 0x6A }, /* 128x gain ceiling; 0x8 is reserved bit */
    { 0x4f, 0x80 },   /* "matrix coefficient 1" */
    { 0x50, 0x80 },   /* "matrix coefficient 2" */
    { 0x51, 0 },    /* vb */
    { 0x52, 0x22 },   /* "matrix coefficient 4" */
    { 0x53, 0x5e },   /* "matrix coefficient 5" */
    { 0x54, 0x80 },   /* "matrix coefficient 6" */
    { REG_COM13, COM13_UVSAT },
    { 0xff, 0xff },   /* END MARKER */
};

const struct regval_list qvga_ov7670[] PROGMEM = {
    { REG_COM14, 0x19 },
    { 0x72, 0x11 },
    { 0x73, 0xf1 },

    { REG_HSTART, 0x16 },
    { REG_HSTOP, 0x04 },
    { REG_HREF, 0xa4 },
    { REG_VSTART, 0x02 },
    { REG_VSTOP, 0x7a },
    { REG_VREF, 0x0a },

    { 0xff, 0xff }, /* END MARKER */
};
```
Следующая используемая функция предназначена для получения разрешения изображения с разрешением 320 x 240 пикселов.
```C++
void loop(){
    captureImg(320, 240);
}

static void captureImg(uint16_t wg, uint16_t hg){
    uint16_t y, x;

    StringPgm(PSTR("*RDY*"));

    while (!(PIND & 8)); //wait for high
    while ((PIND & 8)); //wait for low

    y = hg;
    while (y--){
        x = wg;
       //while (!(PIND & 256)); //wait for high
        while (x--){
            while ((PIND & 4)); //wait for low
            UDR0 = (PINC & 15) | (PIND & 240);
            while (!(UCSR0A & (1 << UDRE0))); //wait for byte to transmit
            while (!(PIND & 4)); //wait for high
            while ((PIND & 4)); //wait for low
            while (!(PIND & 4)); //wait for high
    }
     //  while ((PIND & 256)); //wait for low
  }
    _delay_ms(100);
}
void StringPgm(const char * str){
  do{
      while (!(UCSR0A & (1 << UDRE0))); //wait for byte to transmit
      UDR0 = pgm_read_byte_near(str);
      while (!(UCSR0A & (1 << UDRE0))); //wait for byte to transmit
  } while (pgm_read_byte_near(++str));
}
```
Модуль успешно прошёл тестирование и была доказана работоспособность формирования изображения (Рис. 7).
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/january/7_%D0%B0%D0%BF%D0%BF%D0%B0%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B5_%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B8_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F_OV7670_%D0%BA%D0%B0%D0%BC%D0%B5%D1%80%D1%8B.png"/>
</p>
<p align="center">Рисунок 7 – Аппаратное подключение и тестирование модуля OV7670 камеры</p>