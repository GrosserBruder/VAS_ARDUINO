<h1 align="center">ОТЧЁТ <br> о результатах работы за март 2021 года</h1>
 
#### За отчётный период было выполнено следующее:
#### 1,2. Развод и пайка проводов на управляющее устройство для добавления информационного модуля индикационного отображения состояний удалённых объектов, входящих в состав программно-аппаратного комплекса. Тестирование всего программно-аппаратного комплекса в целом с целью проверки качества интеграции разработанных модулей в существующей системе.

Для повышения надёжности работы управляющего устройства необходимо прибегнуть к аппаратной пайке приходящих к нему проводов. Также в ПАК был добавлен аппаратный модуль индикационного отображения состояний каждого из удалённых объектов, путём интеграции к управляющему устройству LED-светодиодов. Для этого необходимо использовать следующее оборудование и материалы: 
1.  Паяльник или паяльная станция;
2.  Олово;
3.  Канифоль;
4.  Кусачки или зажигалка;
5.  LED-светодиоды (5мм).

LED-светодиоды отображают состояние несанкционированного доступа и задымлённости удалённых объектов (Рис. 1).
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/march/1_%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D1%81%D0%B2%D0%B5%D1%82%D0%BE%D0%B4%D0%B8%D0%BE%D0%B4_%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D1%8E%D1%89%D0%B8%D0%B9_%D0%BD%D0%B5%D1%81%D0%B0%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF_(%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%B8%D0%B5_%D0%B4%D0%B2%D0%B5%D1%80%D0%B8)_%D0%BD%D0%B0_%D1%83%D0%B4%D0%B0%D0%BB%D1%91%D0%BD%D0%BD%D0%BE%D0%BC_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B5_2.jpg"/>
</p>
<p align="center">Рисунок 1 – Включенный светодиод, означающий несанкционированный доступ (открытие двери) на удалённом устройстве №2</p>

В дальнейшем, при расширении ПАК, а именно замены модели платы управляющего устройства с Arduino Uno на Arduino Mega будет возможность добавить большее количество состояний удаленных объектов с помощью LED-светодиодов, например, низкий уровень напряжения в сети, повышенные показания температуры, повышенная влажность и другие.

После аппаратного подключения информационного модуля к управляющему устройству остаётся реализовать программную часть для данного модуля и убедиться в её правильной работоспособности.
Для управляющего устройства было написано 2 функции, отвечающие за включение (выключение) светодиодов в зависимости от входящего параметра с уникальным идентификатором устройства и передаваемых параметров с датчиков дыма – функция turnOnOrOffLedSmokePins
(int deviceId) и датчика с герконом – функция turnOnOrOffLedGerkonPins
(int deviceId). В листинге 1.1 находиться код, в котором вызываются нижеописанные функции из листинга 1.2 и листинга 1.3.

Листинг 1.1 – Функция «loop()»:
```C++  
void loop() {
    if (ETrx.receiveData())
    {
      String convertIsOpenDoorValue; // String значение текущего положения двери - open/close
      char outstr[4];
      Serial.print("rxdata - ");
      Serial.println(rxdata.ID);
      switch (rxdata.ID)
      {
      case 1:
        turnOnOrOffLedGerkonPins(1);
        turnOnOrOffLedSmokePins(1);
      …………………………………
      case 2:
        turnOnOrOffLedGerkonPins(2);
        turnOnOrOffLedSmokePins(2);
        …………………………………
      }
    }
}
```
Листинг 1.2 – Функция «turnOnOrOffLedGerkonPins(int deviceId)»:
```C++  
void turnOnOrOffLedGerkonPins(int deviceId){
    switch (deviceId){
      case 1:
      if(rxdata.isOpen == 1){
        digitalWrite(GERKON_LED_PIN_DEVICE_1, HIGH);
      }else{
        digitalWrite(GERKON_LED_PIN_DEVICE_1, LOW);
      }
      break;
      
      case 2:
      if(rxdata.isOpen == 1){
        digitalWrite(GERKON_LED_PIN_DEVICE_2, HIGH);
      }else{
        digitalWrite(GERKON_LED_PIN_DEVICE_2, LOW);
      }
      break;

      default:
      Serial.print("Error turning on/off LED GERKON pin with ID device = ");
      Serial.println(deviceId);  
      break;
    }
}
```
Листинг 1.3 – Функция «turnOnOrOffLedSmokePins(int deviceId)»:
```C++  
void turnOnOrOffLedSmokePins(int deviceId){
    switch (deviceId){
      case 1:
      if(rxdata.smoke > 700){
        digitalWrite(SMOKE_LED_PIN_DEVICE_1, HIGH);
      }else{
        digitalWrite(SMOKE_LED_PIN_DEVICE_1, LOW);
      }
      break;
      
      case 2:
      if(rxdata.smoke > 700){
        digitalWrite(SMOKE_LED_PIN_DEVICE_2, HIGH);
      }else{
        digitalWrite(SMOKE_LED_PIN_DEVICE_2, LOW);
      }
      break;

      default:
      Serial.print("Error turning on/off SMOKE GERKON pin with ID device = ");
      Serial.println(deviceId);  
      break;
    }
}
```

#### 3. Оптимизация разработанной прошивки для управляемого и управляемых устройств.

Для оптимизации разработанной прошивки для управляющего и управляемого устройств для микроконтроллеров семейства Arduino существует механизм прерывания. Он позволяет внешним устройствам взаимодействовать с контроллером при возникновении разных событий (включение и выключение кнопки, нажатие клавиатуры, мыши, тики таймера RTC, получение новых данных по UART, I2C или SPI).

Прерывание – это сигнал, который сообщает процессору о наступлении какого-либо события, которое требует незамедлительного внимания. Процессор должен отреагировать на этот сигнал, прервав выполнение текущих инструкций и передав управление обработчику прерывания (ISR, Interrupt Service Routine). Обработчик – это обычная функция, которую мы пишем сами и помещаем туда тот код, который должен отреагировать на событие.

После обслуживания прерывания ISR функция завершает свою работу и процессор возвращается к прерванным занятиям – продолжает выполнять код с того места, в котором остановился (Рис. 2). 
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/march/2_%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B_%D0%BF%D1%80%D0%B5%D1%80%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9_%D0%B2_Arduino.png"/>
</p>
<p align="center">Рисунок 2 – Принцип работы прерываний в Arduino</p>

Все это происходит автоматически, поэтому задача заключается только в написании обработчика прерывания, ничего при этом не сломав и не заставляя процессор слишком часто отвлекаться. Понадобится понимание схемы, принципов работы подключаемых устройств и представление о том, как часто может вызываться прерывание, каковы особенности его возникновения. Все это и составляет основную сложность работы с прерываниями.

Прерывания в Arduino разделяются на несколько видов:
1.  Аппаратные. Прерывание на уровне микропроцессорной архитектуры. Самое событие может произойти в производительный момент от внешнего устройства – например, нажатие кнопки на клавиатуре, движение компьютерной мыши и других событий. 
2.  Программные.  Запускаются внутри программы с помощью специальной инструкции. Используются для того, чтобы вызвать обработчик прерываний.
3.  Внутренние (синхронные). Внутреннее прерывание возникает в результате изменения или нарушения в исполнении программы (например, при обращении к недопустимому адресу, недопустимый код операции и другие).

Аппаратные прерывания возникают в ответ на внешнее событие и исходят от внешнего аппаратного устройства. В Ардуино представлены 4 типа аппаратных прерываний. Все они различаются сигналом на контакте прерывания:
1.  Контакт притянут к земле. Обработчик прерывания исполняется до тех пор, пока на пине прерывания будет сигнал LOW.
2.  Изменение сигнала на контакте. В таком случае Ардуино выполняет обработчик прерывания, когда на пине прерывания происходит изменение сигнала. 
3.  Изменение сигнала от LOW к HIGH на контакте – при изменении с низкого сигнала на высокий будет исполняться обработчик прерывания.
4.  Изменение сигнала от HIGH к LOW на контакте – при изменении с высокого сигнала на низкий будет исполняться обработчик прерывания.

Для работы с прерываниями в Arduino используется стандартная функция attachInterrupt(). В зависимости от аппаратной реализации конкретной модели микроконтроллера есть несколько вариантов расположения пинов, обладающих возможность прерывания. Плата Arduino Uno имеет 2 прерывания на втором и третьем пине, но если требуется более двух выходов, плата поддерживает специальный режим «pin-change» (Рис. 3). 
<p align="center">
  <img src="https://github.com/NekitJavaDev/VAS_ARDUINO/blob/master/src/img/march/3_%D1%80%D0%B0%D1%81%D0%BF%D0%BE%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%B8%D0%BD%D0%BE%D0%B2_%D0%BD%D0%B0_%D0%BF%D0%BB%D0%B0%D1%82%D0%B0%D1%85_Arduino_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B5_%D0%B4%D0%BB%D1%8F_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B.png"/>
</p>
<p align="center">Рисунок 3 – Расположение пинов на платах Arduino, используемые для работы с прерываниями</p>

Этот режим работает по изменению входа для всех пинов. Отличие режима прерывания по изменению входа заключается в том, что прерывания могут генерироваться на любом из восьми контактов. Функция attachInterrupt используется для работы с прерываниями. Она служит для соединения внешнего прерывания с обработчиком. 

Синтаксис вызова: attachInterrupt(interrupt, function, mode). 

Аргументы функции:
1.  interrupt – номер вызываемого прерывания (стандартно 0 – для 2-го пина, 1 – для 3-го пина для платы Arduino Uno).
2.  function – название вызываемой функции при прерывании(важно – функция не должна ни принимать, ни возвращать какие-либо значения).
3.  mode – условие срабатывания прерывания.

Возможна установка следующих вариантов условий срабатывания:
1.  LOW – выполняется по низкому уровню сигнала, когда на контакте нулевое значение. Прерывание может циклично повторяться – например, при нажатой кнопке.
2.  CHANGE – по фронту, прерывание происходит при изменении сигнала с высокого на низкий или наоборот. Выполняется один раз при любой смене сигнала.
3.  RISING – выполнение прерывания один раз при изменении сигнала от LOW к HIGH.
4.  FALLING – выполнение прерывания один раз при изменении сигнала от HIGH к LOW.

При работе с прерываниями нужно обязательно учитывать следующие важные ограничения:
1.  Функция-обработчик не должна выполняться слишком долго. Все дело в том, что Arduino не может обрабатывать несколько прерываний одновременно. Пока выполняется функция-обработчик, все остальные прерывания останутся без внимания и можно пропустить важные события. Если планируется обрабатывать большое количество событий с огромным массивом данных – необходимо передавать обработку событий в основном цикле loop(), а в обработчике можно лишь устанавливать флаг события, а в loop – проверять флаг и обрабатывать его.
2.  Интеллектуальный компилятор C++ может «переоптимизировать» написанную прошивку – убрать не нужные, на его взгляд, переменные. Компилятор просто не увидит, что вы устанавливаете какие-то переменные в одной части, а используете – в другой. Для устранения такой вероятности в случае с базовыми типами данных можно использовать ключевое слово volatile, например: volatile boolean state = 0. Но этот метод не сработает со сложными структурами данных.
3.  Не рекомендуется использовать большое количество прерываний 
(более 6-8). Большое количество разнообразных событий требует серьезного усложнения кода, а, значит, ведет к ошибкам. К тому же надо понимать, что ни о какой временной точности исполнения в системах с большим количеством прерываний речи быть не может – нельзя точно определить, каков промежуток между вызовами важных команд.
4.  В обработчиках категорически нельзя использовать delay(). Механизм определения интервала задержки использует таймеры, а они тоже работают на прерываниях, которые заблокирует обработчик. По этой же причине нельзя использовать протоколы связи, основанные на прерываниях (например, I2C).